
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <EEPROM.h>
#include "password.h"
//#include <string> // Include the string library

// EEPROM Configuration
#define EEPROM_SIZE 512
#define SSID_ADDR 0
#define PASSWORD_ADDR 64
#define MQTT_SERVER_ADDR 128
#define CONFIG_FLAG_ADDR 192

// Default MQTT Broker Details
const char* default_mqtt_server = "35.200.133.222";  
const int mqtt_port = 1883;
const char* mqtt_user = "mps-bam100";
const char* mqtt_password = "bam100";

// Dynamic credentials (will be loaded from EEPROM or set via serial)
String wifi_ssid = "";
String wifi_password = "";
String mqtt_server = "";

// Configuration mode flag
bool configMode = false;
const unsigned long configTimeout = 30000; // 30 seconds timeout
unsigned long configStartTime = 0;

// MQTT Client Setup
WiFiClient espClient;
PubSubClient client(espClient);

// Device Details
//String device_id = "ESP32-" + String(ESP.getEfuseMac(), HEX);
//String device_id = "123456";
String device_id = "123456";
const char* device_serial = "234AM87695";
const char* firmware_version = "2.01";

// EEPROM Functions
void initEEPROM() {
  EEPROM.begin(EEPROM_SIZE);
}

void saveCredentials() {
  // Save SSID
  for (int i = 0; i < wifi_ssid.length(); i++) {
    EEPROM.write(SSID_ADDR + i, wifi_ssid[i]);
  }
  EEPROM.write(SSID_ADDR + wifi_ssid.length(), '\0');
  
  // Save Password
  for (int i = 0; i < wifi_password.length(); i++) {
    EEPROM.write(PASSWORD_ADDR + i, wifi_password[i]);
  }
  EEPROM.write(PASSWORD_ADDR + wifi_password.length(), '\0');
  
  // Save MQTT Server
  for (int i = 0; i < mqtt_server.length(); i++) {
    EEPROM.write(MQTT_SERVER_ADDR + i, mqtt_server[i]);
  }
  EEPROM.write(MQTT_SERVER_ADDR + mqtt_server.length(), '\0');
  
  // Set config flag
  EEPROM.write(CONFIG_FLAG_ADDR, 1);
  EEPROM.commit();
  Serial.println("✅ Credentials saved to EEPROM");
}

void loadCredentials() {
  Serial.println("🔍 Loading credentials from EEPROM...");
  
  // Check if credentials exist
  if (EEPROM.read(CONFIG_FLAG_ADDR) != 1) {
    Serial.println("📝 No saved credentials found, using defaults");
    wifi_ssid = String(ssid);
    wifi_password = String(password);
    mqtt_server = String(default_mqtt_server);
    Serial.println("📋 Default credentials loaded:");
    Serial.println("   SSID: " + wifi_ssid);
    Serial.println("   MQTT Server: " + mqtt_server);
    return;
  }
  
  // Load SSID
  wifi_ssid = "";
  for (int i = 0; i < 64; i++) {
    char c = EEPROM.read(SSID_ADDR + i);
    if (c == '\0') break;
    wifi_ssid += c;
  }
  
  // Load Password
  wifi_password = "";
  for (int i = 0; i < 64; i++) {
    char c = EEPROM.read(PASSWORD_ADDR + i);
    if (c == '\0') break;
    wifi_password += c;
  }
  
  // Load MQTT Server
  mqtt_server = "";
  for (int i = 0; i < 64; i++) {
    char c = EEPROM.read(MQTT_SERVER_ADDR + i);
    if (c == '\0') break;
    mqtt_server += c;
  }
  
  Serial.println("✅ Loaded credentials from EEPROM:");
  Serial.println("   SSID: " + wifi_ssid);
  Serial.println("   Password: " + String(wifi_password.length()) + " characters");
  Serial.println("   MQTT Server: " + mqtt_server);
}

void clearCredentials() {
  for (int i = 0; i < 64; i++) {
    EEPROM.write(SSID_ADDR + i, 0);
    EEPROM.write(PASSWORD_ADDR + i, 0);
    EEPROM.write(MQTT_SERVER_ADDR + i, 0);
  }
  EEPROM.write(CONFIG_FLAG_ADDR, 0);
  EEPROM.commit();
  Serial.println("🗑️ Credentials cleared from EEPROM");
}

// Forward declaration
void handleConfigInput(String input);
void showCurrentConfig();

// Serial Configuration Functions
void showConfigMenu() {
  Serial.println("\n=== ESP32 CONFIG ===");
  Serial.println("SSID: " + wifi_ssid);
  Serial.println("MQTT: " + mqtt_server);
  Serial.println("\nCommands:");
  Serial.println("'config' - Change settings");
  Serial.println("'show' - Display current configuration");
  Serial.println("'skip' - Use current settings");
  Serial.println("'clear' - Reset to defaults");
  Serial.println("\n⏰ Timeout: 30 seconds");
}

void showCurrentConfig() {
  Serial.println("\n📋 === CURRENT CONFIGURATION ===");
  Serial.println("🔧 Device Information:");
  Serial.println("   Device ID: " + device_id);
  Serial.println("   Serial Number: " + String(device_serial));
  Serial.println("   Firmware Version: " + String(firmware_version));
  Serial.println("   MAC Address: " + WiFi.macAddress());
  
  Serial.println("\n🌐 Network Configuration:");
  Serial.println("   WiFi SSID: " + wifi_ssid);
  Serial.println("   WiFi Password: " + String(wifi_password.length()) + " characters");
  Serial.println("   WiFi Status: " + String(WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected"));
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("   IP Address: " + WiFi.localIP().toString());
    Serial.println("   Gateway: " + WiFi.gatewayIP().toString());
    Serial.println("   Subnet: " + WiFi.subnetMask().toString());
    Serial.println("   DNS: " + WiFi.dnsIP().toString());
    Serial.println("   RSSI: " + String(WiFi.RSSI()) + " dBm");
  }
  
  Serial.println("\n📡 MQTT Configuration:");
  Serial.println("   MQTT Server: " + mqtt_server);
  Serial.println("   MQTT Port: " + String(mqtt_port));
  Serial.println("   MQTT User: " + String(mqtt_user));
  Serial.println("   MQTT Status: " + String(client.connected() ? "Connected" : "Disconnected"));
  
  if (client.connected()) {
    Serial.println("   Subscribed Topics:");
    Serial.println("     - MPS/global/" + device_id + "/config");
    Serial.println("     - MPS/global/" + device_id + "/control");
    Serial.println("     - MPS/global/" + device_id + "/reboot");
    Serial.println("     - MPS/global/" + device_id + "/scene");
  }
  
  Serial.println("\n💾 EEPROM Status:");
  Serial.println("   Config Saved: " + String(EEPROM.read(CONFIG_FLAG_ADDR) == 1 ? "Yes" : "No"));
  Serial.println("   Uptime: " + String(millis() / 1000) + " seconds");
  Serial.println("================================\n");
}

void handleSerialInput() {
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    input.trim();
    
    // Only convert to lowercase for command checking, not for credential values
    String command = input;
    command.toLowerCase();
    
    if (command == "config") {
      configMode = true;
      configStartTime = millis();
      Serial.println("\n🔧 Config Mode:");
      Serial.println("📡 MQTT Server IP (current: " + mqtt_server + "):");
      Serial.println("   Press Enter to keep current value");
    }
    else if (command == "show") {
      showCurrentConfig();
    }
    else if (command == "skip") {
      Serial.println("\nUsing current settings...");
      configMode = false;
    }
    else if (command == "clear") {
      clearCredentials();
      loadCredentials();
      showConfigMenu();
    }
    else if (configMode) {
      handleConfigInput(input); // Pass original input (not lowercase) for credentials
    }
    else {
      Serial.println("\nUnknown command. Try: config, show, skip, clear");
      showConfigMenu();
    }
  }
}

void handleConfigInput(String input) {
  static int configStep = 0; // 0: MQTT Server, 1: SSID, 2: Password
  
  if (configStep == 0) {
    if (input.length() > 0) {
      mqtt_server = input;
      Serial.println("✅ MQTT Server: " + mqtt_server);
    } else {
      Serial.println("⏭️ Keeping current MQTT Server: " + mqtt_server);
    }
    Serial.println("\n📶 WiFi SSID (current: " + wifi_ssid + "):");
    Serial.println("   Press Enter to keep current SSID");
    configStep = 1;
  }
  else if (configStep == 1) {
    if (input.length() > 0) {
      wifi_ssid = input;
      Serial.println("✅ SSID: " + wifi_ssid);
    } else {
      Serial.println("⏭️ Keeping current SSID: " + wifi_ssid);
    }
    Serial.println("\n🔐 WiFi Password (current: " + String(wifi_password.length()) + " characters):");
    Serial.println("   Press Enter to keep current password");
    configStep = 2;
  }
  else if (configStep == 2) {
    if (input.length() > 0) {
      wifi_password = input;
      Serial.println("✅ Password: Updated");
    } else {
      Serial.println("⏭️ Keeping current password");
    }
    
    Serial.println("\n💾 Saving configuration...");
    saveCredentials();
    
    Serial.println("✅ Configuration saved!");
    Serial.println("📋 Final Settings:");
    Serial.println("   MQTT Server: " + mqtt_server);
    Serial.println("   WiFi SSID: " + wifi_ssid);
    Serial.println("   WiFi Password: " + String(wifi_password.length()) + " characters");
    Serial.println("\n🔄 Restarting ESP32...");
    
    configMode = false;
    configStep = 0;
    delay(2000);
    esp_restart();
  }
}

void checkConfigTimeout() {
  if (configMode && (millis() - configStartTime > configTimeout)) {
    Serial.println("\nTimeout! Using current settings...");
    configMode = false;
  }
}

// Timer for Ping Interval
unsigned long lastPingTime = 0;
const unsigned long pingInterval = 30000;

// LED & Shade Control Pins
const int ledPins[] = {2, 4, 5, 18, 19, 21, 22, 23, 25, 26, 27, 32};
const int shadePins[] = {33, 34, 35, 36};

void connectToWiFi() {
  Serial.print("Connecting to WiFi: " + wifi_ssid + "...");
  WiFi.begin(wifi_ssid.c_str(), wifi_password.c_str());
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(1000);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n✅ WiFi connected");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\n❌ WiFi connection failed!");
    Serial.println("Please check your credentials and try again.");
  }
}
// Function to handle the reboot command
void handleRebootCommand(const JsonDocument& doc) {
  if (doc["deviceId"].is<String>() && doc["deviceId"] == "reboot") {
    Serial.println("🔄 Rebooting ESP32...");
    delay(1000); // Short delay before reboot
    esp_restart(); // Reboot the ESP32
  }
}
void sendDeviceDiscovery() {
  JsonDocument doc; // Use JsonDocument instead of StaticJsonDocument
  doc["device_id"] = device_id;
  //doc["SNO"] = "234AM87696";
  doc["SNO"] = "234AM87697";
  doc["Firmware"] = "v1.0.0.1";
  doc["MacAddr"] = WiFi.macAddress();

  char buffer[256];
  serializeJson(doc, buffer);
  client.publish("MPS/global/discovery", buffer, true);
  Serial.println("📢 Published Discovery Data:");
  Serial.println(buffer);
}
void sendConfigResponse() {
  JsonDocument doc;
  doc["ch_t"] = "LED";
  doc["ch_addr"] = "LED1";
  doc["cmd"] = 100; // Replace 100 with your actual deviceConfig.LED_CONFIG value
  doc["cmd_m"] = "config";

  char buffer[256];
  serializeJson(doc, buffer);
  String topic = String("MPS/global/") + device_id + "/config";
  client.publish(topic.c_str(), buffer);
  Serial.println("📤 Sent Config Response:");
  Serial.println(buffer);
}


void connectToMQTT() {
  int attempts = 0;
  const int maxAttempts = 5;
  
  while (!client.connected() && attempts < maxAttempts) {
    attempts++;
    Serial.println("🔄 Connecting to MQTT broker: " + mqtt_server + " (Attempt " + String(attempts) + "/" + String(maxAttempts) + ")");
    Serial.println("📋 Device ID: " + device_id);
    Serial.println("📋 MQTT User: " + String(mqtt_user));
    
    if (client.connect(device_id.c_str(), mqtt_user, mqtt_password)) {
      Serial.println("✅ MQTT connected successfully!");
      Serial.println("📡 Device ID: " + device_id);
            
      // Subscriptions
      String configTopic = "MPS/global/" + device_id + "/config";
      String controlTopic = "MPS/global/" + device_id + "/control";
      String rebootTopic = "MPS/global/" + device_id + "/reboot";
      String sceneTopic = "MPS/global/" + device_id + "/scene";
      
      client.subscribe(configTopic.c_str());
      client.subscribe(controlTopic.c_str());
      client.subscribe(rebootTopic.c_str());
      client.subscribe(sceneTopic.c_str());
      
      Serial.println("📡 Subscribed to topics:");
      Serial.println("   - " + configTopic);
      Serial.println("   - " + controlTopic);
      Serial.println("   - " + rebootTopic);
      Serial.println("   - " + sceneTopic);
      
      sendDeviceDiscovery();
      return; // Exit function on successful connection
    } else {
      Serial.print("❌ MQTT Connection Failed. State: ");
      Serial.println(client.state());
      Serial.println("⏳ Retrying in 5 seconds...");
      delay(5000);
    }
  }
  
  if (attempts >= maxAttempts) {
    Serial.println("❌ MQTT connection failed after " + String(maxAttempts) + " attempts!");
    Serial.println("🔄 Will retry in main loop...");
  }
}


void sendStatusUpdate(String channel, String status) {
  JsonDocument doc;
  doc["device_id"] = device_id;
  doc["ch_t"] = channel.startsWith("LED") ? "LED" : "SHADE";
  doc["ch_addr"] = channel;
  doc["status"] = status;
  
  String payload;
  serializeJson(doc, payload);
  client.publish((String("MPS/global/UP/") + device_id + "/status").c_str(), payload.c_str());
  Serial.println("📤 Sent Status Update: " + payload);
}

void processLEDCommand(const JsonObject& command) {
  String ledAddr = command["ch_addr"].as<String>();
  int cmd = command["cmd"];
  String cmd_m = command["cmd_m"].as<String>();
  
  Serial.println("🔍 LED Command Details:");
  Serial.println("   Address: " + ledAddr);
  Serial.println("   Command: " + String(cmd));
  Serial.println("   Action: " + cmd_m);

  // Check if it's the built-in LED
  if (ledAddr == "LED0") { // Assuming you want to control it via "LED0"
    if (cmd == 104) {
      digitalWrite(BUILTIN_LED, cmd_m == "LED_ON" ? HIGH : LOW);
      sendStatusUpdate(ledAddr, cmd_m == "LED_ON" ? "on" : "off");
      Serial.println("💡 LED0: " + String(cmd_m == "LED_ON" ? "ON" : "OFF"));
    } else if (cmd == 102) {
      // Brightness control (if applicable)
      int brightness = command["cmd_m"].as<int>();
      analogWrite(BUILTIN_LED, map(brightness, 0, 100, 0, 255));
      sendStatusUpdate(ledAddr, String(brightness) + "%");
      Serial.println("💡 LED0: Brightness " + String(brightness) + "%");
    }
  } else {
    // Original LED control logic
    int ledIndex = ledAddr.substring(3).toInt() - 1;
    Serial.println("🔢 LED Index: " + String(ledIndex));
    
    if (ledIndex >= 0 && ledIndex < sizeof(ledPins)/sizeof(ledPins[0])) {
      if (cmd == 104) {
        digitalWrite(ledPins[ledIndex], cmd_m == "LED_ON" ? HIGH : LOW);
        sendStatusUpdate(ledAddr, cmd_m == "LED_ON" ? "on" : "off");
        Serial.println("💡 " + ledAddr + ": " + String(cmd_m == "LED_ON" ? "ON" : "OFF"));
      } else if (cmd == 102) {
        int brightness = command["cmd_m"].as<int>();
        analogWrite(ledPins[ledIndex], map(brightness, 0, 100, 0, 255));
        sendStatusUpdate(ledAddr, String(brightness) + "%");
        Serial.println("💡 " + ledAddr + ": Brightness " + String(brightness) + "%");
      }
    } else {
      Serial.println("❌ Invalid LED index: " + String(ledIndex));
    }
  }
}




void processShadeCommand(const JsonObject& command) {
  String shadeAddr = command["ch_addr"].as<String>();
  int shadeIndex = shadeAddr.substring(5).toInt() - 1;

  if (shadeIndex >= 0 && shadeIndex < sizeof(shadePins)/sizeof(shadePins[0])) {
    if (command["cmd"] == 113) {
      digitalWrite(shadePins[shadeIndex], HIGH);
      sendStatusUpdate(shadeAddr, "open");
      Serial.println(shadeAddr + ": OPENED");
    }
    else if (command["cmd"] == 114) {
      digitalWrite(shadePins[shadeIndex], LOW);
      sendStatusUpdate(shadeAddr, "closed");
      Serial.println(shadeAddr + ": CLOSED");
    }
    else if (command["cmd"] == 111) {
      // Assuming 'stop' means no signal
      digitalWrite(shadePins[shadeIndex], LOW); // Or whatever stops the motor
      sendStatusUpdate(shadeAddr, "stopped");
      Serial.println(shadeAddr + ": STOPPED");
    }
  }
}


void sendPing() {
  JsonDocument pingDoc;
  pingDoc["device_id"] = device_id;
  pingDoc["status"] = "online";
  pingDoc["uptime"] = millis() / 1000;
  pingDoc["rssi"] = WiFi.RSSI();

  String pingBuffer;
  serializeJson(pingDoc, pingBuffer);
  client.publish("MPS/global/sessionPing", pingBuffer.c_str());
  Serial.println("📡 Sent Ping: " + pingBuffer);
}

void processSceneCommand(const JsonObject& command) {
  Serial.println("🎨 Processing Scene Command...");
  JsonVariant cmd_m = command["cmd_m"];
  JsonArray channels = command["ch_addr"].as<JsonArray>();

  Serial.println("📋 Scene Command Details:");
  Serial.println("   Channels: " + String(channels.size()));

  // Handle LED ON/OFF commands
  if (cmd_m.is<const char*>()) { // String command
    String action = cmd_m.as<String>();
    Serial.println("   Action: " + action);
    if (action == "LED_ON" || action == "LED_OFF") {
      for (JsonVariant ch : channels) {
        int channelNum = ch.as<int>(); // Get integer from array
        if (channelNum >= 1 && channelNum <= 12) {
          String ledAddr = "LED" + String(channelNum);
          int ledIndex = channelNum - 1;
          digitalWrite(ledPins[ledIndex], action == "LED_ON" ? HIGH : LOW);
          sendStatusUpdate(ledAddr, action == "LED_ON" ? "on" : "off");
          Serial.println("💡 " + ledAddr + ": " + String(action == "LED_ON" ? "ON" : "OFF"));
        }
      }
    }
  }
  // Handle brightness commands
  else if (cmd_m.is<JsonObject>()) { // Object command
    JsonObject brightnessCmd = cmd_m.as<JsonObject>();
    if (brightnessCmd["LED_BRIGHTNESS"].is<int>()) {
      int brightness = brightnessCmd["LED_BRIGHTNESS"];
      Serial.println("   Brightness: " + String(brightness) + "%");
      for (JsonVariant ch : channels) {
        int channelNum = ch.as<int>();
        if (channelNum >= 1 && channelNum <= 12) {
          String ledAddr = "LED" + String(channelNum);
          int ledIndex = channelNum - 1;
          analogWrite(ledPins[ledIndex], map(brightness, 0, 100, 0, 255));
          sendStatusUpdate(ledAddr, String(brightness) + "%");
          Serial.println("💡 " + ledAddr + ": Brightness " + String(brightness) + "%");
        }
      }
    }
  }
}



void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("📩 Message received on topic: ");
  Serial.println(topic);
  Serial.print("📦 Payload length: ");
  Serial.println(length);
  Serial.print("📄 Raw payload: ");
  for (int i = 0; i < length; i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();

  JsonDocument doc;
  DeserializationError error = deserializeJson(doc, payload, length);
  if (error) {
    Serial.print("❌ JSON Parsing Error: ");
    Serial.println(error.c_str());
    return;
  }

  String topicStr(topic);
  
  if (topicStr.endsWith("/config")) {
    Serial.println("⚙️ Received config message");
    JsonObject obj = doc.as<JsonObject>();
    // Only respond to config requests (e.g., cmd == 106 and cmd_m == "config")
    if (obj["cmd"].is<int>() && obj["cmd"] == 106 && obj["cmd_m"] == "config") {
      sendConfigResponse();
    }
  }
  else if (topicStr.endsWith("/control")) {
    Serial.println("🎮 Control command received");
    JsonObject obj = doc.as<JsonObject>();
    String ch_type = obj["ch_t"].as<String>();
    String ch_addr = obj["ch_addr"].as<String>();
    int cmd = obj["cmd"];
    Serial.println("📋 Type: " + ch_type + ", Address: " + ch_addr + ", Cmd: " + String(cmd));
    
    if (ch_type == "LED") {
      Serial.println("💡 Processing LED command...");
      processLEDCommand(obj);
    }
    else if (ch_type == "SHADE") {
      Serial.println("🪟 Processing Shade command...");
      processShadeCommand(obj);
    }
  }
  else if (topicStr.endsWith("/scene")) {
    Serial.println("🎨 Received scene command");
    JsonObject obj = doc.as<JsonObject>();
    processSceneCommand(obj);
  }
  else if (topicStr.endsWith("/reboot")) {
    Serial.println("🔄 Received reboot command");
    handleRebootCommand(doc);
  }
}

void setup() {
  Serial.begin(9600);
  delay(2000); // Give time for serial to initialize
  
  Serial.println("\n🚀 ESP32 Starting...");
  Serial.println("📋 Device ID: " + device_id);
  Serial.println("📋 Serial Number: " + String(device_serial));
  Serial.println("📋 Firmware Version: " + String(firmware_version));
  
  // Initialize EEPROM and load credentials
  initEEPROM();
  loadCredentials();
  
  // Show configuration menu
  showConfigMenu();
  configStartTime = millis();
  
  // Wait for configuration or timeout
  while (configMode || (millis() - configStartTime < configTimeout)) {
    handleSerialInput();
    checkConfigTimeout();
    delay(10);
  }
  
  if (!configMode) {
    Serial.println("\n🎯 Starting normal operation...");
    Serial.println("📡 Final Configuration:");
    Serial.println("   WiFi SSID: " + wifi_ssid);
    Serial.println("   MQTT Server: " + mqtt_server);
    Serial.println("   Device ID: " + device_id);
    
    // Ensure config mode is completely disabled
    configMode = false;
    
    // Initialize pins
    Serial.println("🔌 Initializing GPIO pins...");
    for (int pin : ledPins) {
      pinMode(pin, OUTPUT);
      digitalWrite(pin, LOW);
    }
    for (int pin : shadePins) {
      pinMode(pin, OUTPUT);
      digitalWrite(pin, LOW);
    }
    Serial.println("✅ GPIO pins initialized");
    
    // Connect to WiFi and MQTT
    Serial.println("🌐 Connecting to WiFi...");
    connectToWiFi();
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("📡 Setting up MQTT client...");
      client.setServer(mqtt_server.c_str(), mqtt_port);
      client.setCallback(callback);
      connectToMQTT();
    } else {
      Serial.println("❌ WiFi connection failed, cannot connect to MQTT");
    }
    
    Serial.println("\n💡 Tip: Type 'show' in Serial Monitor to view current configuration");
  }
}

void loop() {
  // Handle configuration mode
  if (configMode) {
    handleSerialInput();
    checkConfigTimeout();
    return;
  }
  
  // Handle serial input for show command even in normal operation
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    input.trim();
    String command = input;
    command.toLowerCase();
    
    if (command == "show") {
      showCurrentConfig();
    }
  }
  
  // Normal operation
  if (!client.connected()) {
    Serial.println("⚠️ MQTT disconnected, attempting to reconnect...");
    connectToMQTT();
  }
  client.loop();

  if (millis() - lastPingTime >= pingInterval) {
    sendPing();
    lastPingTime = millis();
  }
}